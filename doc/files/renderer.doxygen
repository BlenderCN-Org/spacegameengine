/**
\page renderer renderer

\section abstract Abstract

sge::renderer provides an abstraction for 3D APIs, which currently is
mainly focused on the fixed function pipeline to guarantee maximum portability.
A glsl interface is also provided but can only be used with OpenGL.

\section vertices Vertices
The basic resource of a renderer are so called \em vertices, which are 3d
points with additional attributes like normals, texture coordinates, or even
user defined types. These vertices are used to define triangles, lines or
points, which are called \em primitives. The additional attributes can change
the way how primitives are rendered (for example, with texture coordinates,
texturing will be taken into account).

To actually store vertices on the graphics card, an
sge::renderer::vertex_buffer must be created. Internally, however, this buffer
is simply that, an array of bytes. To make filling data into the buffer easy,
sge implements an almost compile time safe layer on top of the buffers, so that
it is nearly as easy to use as an std::vector of structs. The structure of this
additional layer tells how the buffer is to be used (which attributes the
vertices have) and is therefore called a \em vertex \em format.

The vertex format can be used to create an sge::renderer::vertex_declaration
which is a runtime representation of it.

The distinction between the vertex_buffer and vertex_declaration classes is
necessary because different vertex attributes can be stored in different
vertex_buffers (for example the positions could go into one buffer and the
texture coordinates into another).

\subsection vertex_declarations Vertex declarations

sge offers certain classes that have to be used to declare the attributes of a
vertex.

In the following examples, the goal is to create a triangle with three
different colors for every vertex.

\image html renderer_colored_triangle.png "A triangle with three different vertex colors"

The first vertex attribute we declare is a position.  This is always needed if
you use the fixed function pipeline.

\snippet vertex.cpp position_declaration

This indicates that the vertex position should consist of three floats, which
are x, y and z, respectively.  Anything else is not really portable.  You can,
however, use double element types or positions with 2 or 4 coordinates with
OpenGL.

The next code snippet shows how to declare a color attribute.

\snippet vertex.cpp color_declaration

Here, a bgra8 color format is used that consists of 8 bits per color channel.

An sge::renderer::vf::part is a collection of vertex attributes that are to be
stored in a single vertex buffer.  Only one part is used in this example, so
both the position and the color go into it.

\snippet vertex.cpp format_part_declaration

The final thing to complete the vertex format is the format declaration that
tells of which parts the format will be made.

\snippet vertex.cpp format_declaration

The vertex_declaration is created from an sge::renderer::device, which is
available through sys.renderer() in this example.

\snippet vertex.cpp vertex_declaration

\subsection writing_vertices Writing Vertices

In order to fill a vertex_buffer, we first have to create one.  The
vertex_buffer has to be told which part of the vertex format it is going to
hold and which vertex declaration it belongs to.

\snippet vertex.cpp vertex_buffer

The vertex buffer consists of three elements, which are enough to create a
triangle from.

The next step is to get the vertex data into the buffer.

A renderer resource, such as a vertex buffer, cannot be read or written under
normal circumstances. To actually access its data, the resource must be \em
locked. Depending on the lock mode, the resource can be either read or written,
or both.  If you are done with reading or writing, the resource must be \em
unlocked again for the updates to actually take place.

In this example, we want to lock the whole vertex buffer for writing.  This is
done through an sge::renderer::scoped_vertex_lock that locks the vertex buffer
in its constructor and unlocks it in its destructor. We also put this into a
new block, so the destructor gets called when we desire (close the block).

\snippet vertex.cpp vblock_declaration

The final step is to connect the lock of the buffer with our vertex format
part. Therefore, we create an sge::renderer::vf::view on top of the buffer
lock.

\snippet vertex.cpp vertex_view_declaration

Here is why the extra layer is not completely compile time safe: If you mix a
vertex_buffer and a vertex format part that don't correspond to each other, you
will get an exception in the constructor of the vertex view.

The view provides begin and end methods which return iterators.

\snippet vertex.cpp vertex_iterator_declaration

Dereferencing these iterators yields a vertex structure whose attributes can be
accessed via the special classes that we typedeffed earlier.

\snippet vertex.cpp vertex_write_pos_1

In this example the pos3_type, that we typedeffed earlier, is used to access
the position of the vertex the iterator is pointing to. The type that has to be
used to write to the position is its packed_type. In this case, the packed_type
is a vector of three float elements.

The color is accessed in a similar fashion. The packed_type of the color is an
sge::image::color::bgra8. Here we use sge's predefined color cyan and convert
it to a bgra8 color.

\snippet vertex.cpp vertex_write_color_1

The rest of the vertices get written in a similar fashion.

\snippet vertex.cpp vertex_write_rest

We are done with the vertex lock and the scope is closed, so the buffer will be
unlocked.

\subsubsection drawing_vertices Drawing Vertices

To draw some of the vertices from the vertex buffer, we have to enable both the
vertex declaration and the vertex buffer using the renderer.  Therefore, we
create a new block that runs in a loop.

\snippet vertex.cpp running_block

sge::renderer::scoped_vertex_declaration sets the vertex declaration in its
constructor and unsets it in the destructor.
sge::renderer::scoped_vertex_buffer does the same but to a vertex buffer.

\snippet vertex.cpp scoped_declaration

Drawing can only be done between calls to
sge::renderer::device::begin_rendering and
sge::renderer::device::end_rendering.  An sge::renderer::scoped_block does this
in its constructor and destructor, respectively.

\snippet vertex.cpp scoped_block

We tell the renderer to draw the vertices 0 through 2 from the vertex buffer,
interpreting them as a list of triangles.
*/
